<!doctype html>
<html lang="en-GB"><head><meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">

	<title>Infinite scroll | Examples | Ractive.js</title>

	
	
	<link rel="stylesheet" href="examples.css">

	

	<style id="example-css" type="text/css">.scroller {
	height: 25em;
	border-top: 1px solid #aaa;
	border-bottom: 1px solid #aaa;
	background-color: #f9f9f9;
	overflow-y: scroll;
	-webkit-overflow-scrolling: touch;
}

ul {
	padding: 0;
	margin: 0 0 2000px 0;
	list-style: none;
}

.post {
	position: relative;
	clear: both;
	padding: 0.5em 0.5em 0.5em 5.5em;
	min-height: 5em;
	border-bottom: 1px dotted #ccc;

	-webkit-box-sizing: border-box;
	-moz-box-sizing: border-box;
	box-sizing: border-box;
}

.post:nth-child(odd) {
	background-color: #f6f6f6;
}

.post:after {
	content: '';
	display: table;
	clear: both;
}

.avatar {
	position: absolute;
	top: 0.5em;
	left: 0.5em;
	width: 4em;
	height: auto;
}

.author {
	font-family: 'Voltaire';
}

.post-content {
	width: 100%;
	overflow-x: auto;
}

.newer {
	display: block;
	background-color: #f9fcf6;
	text-align: center;
	padding: 0.5em;
	cursor: pointer;
	border-bottom: 1px dotted #ccc;
}

.error {
	float: left;
	color: rgb(255,150,150);
	margin: 0.5em 0;
}

.source {
	float: right;
	color: #999;
	margin: 0.5em 0;
}

#example br {
	display: none;
}</style></head>

<body class="example"><header><h1>Infinite scroll</h1>
		<a class="more-examples" href="./">more Ractive.js examples &raquo;</a></header>

	<div class="example-container"><div id="example"><noscript><p class=message>Please <a href=www.enable-javascript.com>enable JavaScript</a> to view this example.</p></noscript></div></div>

	<div id="info"></div>


	<script id="infoTemplate" type="ractive"><div class='controls'>
			<span on-tap='select:readme'     class='tab <% selected === "readme"     ? "selected" : "" %>'>readme</span>
			<span on-tap='select:template'   class='tab <% selected === "template"   ? "selected" : "" %>'>template</span>
			<span on-tap='select:javascript' class='tab <% selected === "javascript" ? "selected" : "" %>'>javascript</span>
			<span on-tap='select:css'        class='tab <% selected === "css"        ? "selected" : "" %>'>css</span>
		</div>

		<div class='wrapper'>
			<div id='readme-tab'     class='<% selected === "readme" ? "visible" : "hidden" %>'>
				<p>One of the particular challenges of front-end development is encapsulating functionality in a reusable form. With the rise of things like AMD it's getting better, but it's still hard to find the sweet spot between general solutions (abstract, reusable) and specific ones (better optimised, less verbose configuration).</p>

<p>This is particularly true where the DOM is concerned. One of the goals of <span class='logo'>Ractive.js</span> is to provide a platform for creating these reusable modules.</p>

<p>Take this infinite scroll widget as an example. It's a fairly basic module &ndash; it extends <code>Ractive</code> with some hooks for loading older data when the user scrolls to a certain point, and a simple polling mechanism for loading newer data.</p>

<p>But it doesn't actually make any API requests. That's the job of our app &ndash; to use the hooks provided by the module. In this example, we're loading the <a href='https://app.net'>App.net</a> global stream &ndash; for that we need a function that will make the request using JSONP, and some App.net-specific logic for extracting the data we need from the response (such as getting the ID of the most recent post, so we know which data we need to request next time we poll).</p>

<p>The template also uses partials, so that we can inject app-specific template snippets that reflect the shape of the data we get back from the API.</p>

<p>And because we're using <span class='logo'>Ractive.js</span>, we don't have to faff about with a special <code>Post</code> view class with its own render method, or any such nonsense &ndash; it just works, slick transitions and all.</p>
			</div>

			<pre id='template-tab'   class='prettyprint language-html <% selected === "template" ? "visible" : "hidden" %>'></pre>
			<pre id='javascript-tab' class='prettyprint language-javascript <% selected === "javascript" ? "visible" : "hidden" %>'></pre>
			<pre id='css-tab'        class='prettyprint language-css <% selected === "css" ? "visible" : "hidden" %>'></pre>
		</div></script>

	<script id="example-template" type="text/ractive"><!-- General purpose, reusable infinite scroll template -->

<div class='scroller' on-scroll='scroll'>
  {{#newer.length}}
    <a class='newer' on-tap='showNewer' intro='slide'>
      Show {{newer.length}} new {{ newer.length === 1 ? "post" : "posts" }}
    </a>
  {{/newer.length}}

  <ul id='stream'>
    {{#posts}}
      {{>post}}
    {{/posts}}
  </ul>
</div>

{{#error}}
  <p class='error'>{{errorMessage}}</p>
{{/error}}

{{>footer}}



<!-- App-specific partials -->

<!-- {{>post}} -->
<li class='post'>
  <img intro='fade' class='avatar' src='{{user.avatar_image.url}}'>
  <span intro='fade' class='author'>{{user.username}}</span>
  <div intro='fade' class='post-content'>{{{html}}}</div>
</li>
<!-- {{/post}} -->

<!-- {{>footer}} -->
<p class='source'>Data via the <a href='http://developers.app.net/'>App.net API</a></p>
<!-- {{/footer}} --></script>

	
	<script src="lib/Ractive-legacy.js"></script>
	<script src="lib/Ractive-events-tap.min.js"></script>
	<script src="lib/highlight.js"></script>
	<script src="lib/Ractive-transitions-fade.min.js"></script>
	<script src="lib/Ractive-transitions-slide.min.js"></script>
	<script src="js/example.js"></script>

	<script id="example-javascript">var InfiniteList, fetch, stream, ready, baseUrl, newestId, oldestId, pendingNewerRequest, pendingOlderRequest;

// First, the reusable stuff...
// ============================

// We extend Ractive with some logic that fires custom events - a fetchNewer
// event at regular intervals, and a fetchOlder event when we get to the bottom
// of the list
InfiniteList = Ractive.extend({
  template: template,

  init: function ( options ) {
    var self = this, threshold, interval, intervalId;

    // refresh when user gets within 3000px of the bottom by default. That sounds
    // like a lot, but 2000px of that is padding, and it prevents the page jumping
    // around by making it hard for the user to reach the bottom (at which point
    // the body would start scrolling, awkwardly)
    threshold = options.scrollThreshold || 3000;

    // poll every 10 seconds by default
    interval = ( options.pollInterval === 0 ? 0 : options.pollInterval || 10000 );

    // start polling, unless it was disabled with pollInterval: 0
    if ( interval ) {
      intervalId = setInterval( function () {
        self.fire( 'fetchNewer' );
      }, interval );
    }

    this.on({
      // when the user scrolls the scroller, see if we're near the bottom
      scroll: function ( event ) {
        var scrollerBottom, listBottom;

        scrollerBottom = event.node.getBoundingClientRect().bottom;
        listBottom = this.nodes.stream.getBoundingClientRect().bottom;

        if ( listBottom - scrollerBottom < threshold ) {
          // we need request some more data
          this.fire( 'fetchOlder' );
        }
      },

      // if this gets torn down, we clean up after ourselves and stop polling
      teardown: function () {
        clearInterval( intervalId );
      }
    });
  }
});

// This is a simple JSONP helper function, which is also reusable
fetch = function ( url, queryParams, successHandler, errorHandler ) {
  var scr, handlerId;

  // Allow query params to be included or omitted
  if ( typeof queryParams === 'function' ) {
    errorHandler = successHandler;
    successHandler = queryParams;
    queryParams = [];
  } else if ( typeof queryParams === 'string' ) {
    queryParams = [ queryParams ];
  }

  // Create a unique handler ID
  handlerId = 'jsonpHandler_' + Math.floor( Math.random() * 1000000 );

  // Create a global variable, that will be called when we get an
  // API response
  window[ handlerId ] = function ( response ) {

    // Fire the callback
    successHandler( response );

    // Tidy up
    window[ handlerId ] = null;
    scr.parentNode.removeChild( scr );
  };

  // Create a script element
  scr = document.createElement( 'script' );
  scr.onerror = errorHandler;

  // Add our unique handler ID to the query string
  queryParams.push( 'callback=' + handlerId );
  scr.src = url + '?' + queryParams.join( '&' );

  // Add the script to the document to trigger the request
  document.body.appendChild( scr );
};


// Then, the app-specific, harder to reuse logic
// =============================================


// The API endpoint for the App.net global stream
baseUrl = 'https://alpha-api.app.net/stream/0/posts/stream/global';


// Instantiate our InfiniteList class
stream = new InfiniteList({
  el: example,
  pollInterval: 5000, // poll every 5 seconds
  data: {
    errorMessage: 'Error loading data from App.net'
  }
});


stream.on({
  fetchNewer: function () {

    // Make sure we're not still initialising, and that we're not already
    // making this request
    if ( !ready || pendingNewerRequest ) {
      return;
    }

    pendingNewerRequest = true;

    fetch( baseUrl, 'since_id=' + newestId, function ( response ) {
      var newer, existing = stream.get( 'newer' ) || [];

      newer = ( response.data || [] ).concat( existing );

      if ( newer[0] ) {
        newestId = newer[0].id;
      }

      stream.set( 'newer', newer );

      pendingNewerRequest = false;
      stream.set( 'error', false );
    }, function () {
      pendingNewerRequest = false;
      stream.set( 'error', true );
    });
  },

  fetchOlder: function () {

    // As above, only make the request if appropriate
    if ( !ready || pendingOlderRequest ) {
      return;
    }

    pendingOlderRequest = true;

    fetch( baseUrl, 'before_id=' + oldestId, function ( response ) {
      var posts = stream.get( 'posts' );

      posts.push.apply( posts, response.data );

      oldestId = posts[ posts.length - 1 ].id;

      pendingOlderRequest = false;
      stream.set( 'error', false );
    }, function () {
      pendingOlderRequest = false;
      stream.set( 'error', true );
    });
  },

  // When the user clicks the 'show newer posts' button, render them
  showNewer: function () {
    var posts = stream.get( 'posts' );

    posts.unshift.apply( posts, stream.get( 'newer' ) );
    stream.set( 'newer', [] );
  }
});


// Load the first batch of posts
fetch( baseUrl, function ( response ) {
  var posts = response.data;

  newestId = posts[0].id;
  oldestId = posts[ posts.length - 1 ].id;

  stream.set( 'posts', posts );

  ready = true;
}, function () {
  stream.set( 'error', true );
});</script>

	<script>initExample();</script></body></html>